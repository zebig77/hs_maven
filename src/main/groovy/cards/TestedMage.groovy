package cardsimport game.Cardimport game.CardDefinitionimport game.Gameimport static mechanics.buffs.BuffType.FROZENimport static mechanics.buffs.BuffType.IMMUNEimport static mechanics.buffs.BuffType.TAUNT
class ArcaneExplosion extends CardDefinition {
	ArcaneExplosion() {
		name='Arcane Explosion'; type='spell'; cost=2
		text='Deal 1 damage to all enemy minions.'
		reserved_to="Mage"
		when_played(text) { 			this_spell.deal_spell_damage(1, enemy_minions) 		}
	}
}class ArcaneIntellect extends CardDefinition {	ArcaneIntellect() {		name='Arcane Intellect'; type='spell'; cost=3		text='Draw 2 cards.'		reserved_to="Mage"		when_played(text) { 			you.draw(2) 		}	}}class ArcaneMissiles extends CardDefinition {	ArcaneMissiles() {		name='Arcane Missiles'; type='spell'; cost=1		text='Deal 3 damage randomly split among enemy characters.'		reserved_to="Mage"		when_played(text) {			for (i in 1..you.get_spell_damage(3)) {				def t = random_pick(opponent_hero + enemy_minions)				this_spell.deal_damage(1, t)			}		}	}}class ArchmageAntonidas extends CardDefinition {	ArchmageAntonidas() {		name='Archmage Antonidas'; type='minion'; cost=7; attack=5; max_health=7		text="Whenever you cast a spell, put a 'Fireball' spell into your hand."		reserved_to="Mage"		when_its_controller_plays_a_card(text) {			if (that_card.is_a_spell()) {				you.hand.add( Game.new_card("Fireball") )			}		}	}}class Blizzard extends CardDefinition {	Blizzard() {		name='Blizzard'; type='spell'; cost=6		text='Deal 2 damage to all enemy minions and Freeze them.'		reserved_to='Mage'		when_played(text) {			enemy_minions.each {				this_spell.deal_spell_damage(2, it )				if (! it.is_dead()) {					this_spell.freeze( it )				}			}		}	}}class ConeOfCold extends CardDefinition {	ConeOfCold() {		name='Cone of Cold'; type='spell'; cost=4		text='Freeze a minion and the minions next to it, and deal 1 damage to them.'		reserved_to="Mage"		get_targets=[ { all_minion_targets } ]		when_played(text) {			Card m = select_spell_target( all_minion_targets )			(m + m.neighbors()).each {				this_spell.freeze(it)				this_spell.deal_spell_damage(1, it)			}		}	}}class Counterspell extends CardDefinition {	Counterspell() {		name='Counterspell'; type='spell'; cost=3		text='Secret: When your opponent casts a spell, Counter it.'		reserved_to="Mage"		is_a_secret=true		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			def the_opponent = opponent			the_secret.when_a_spell_is_played("check $text") {				// note: 'a_spell_is_played' happens just after 'a_spell_is_cast'				the_secret.activate_if (that_spell.controller == the_opponent) {					stop_action = true				}			}		}	}}class Duplicate extends CardDefinition {	Duplicate() {		name='Duplicate'; type='spell'; cost=3		text='Secret: When a friendly minion dies, put 2 copies of it into your hand.'		reserved_to="Mage"		is_a_secret=true		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			the_secret.when_a_minion_dies("check $text") {				the_secret.activate_if (that_minion.controller == the_secret.controller) {					2.times {						if (the_secret.controller.hand.size() < 10) {							the_secret.controller.hand.add( Game.new_card(that_minion.name) )						}					}				}			}		}	}}class EtherealArcanist extends CardDefinition {	EtherealArcanist() {		name='Ethereal Arcanist'; type='minion'; cost=4; attack=3; max_health=3		text='If you control a Secret at the end of your turn, gain +2/+2.'		reserved_to="Mage"		when_its_controller_turn_ends(text) {			if (you.secrets.size() != 0) {				this_minion.gain("+2/+2")			}		}	}}class Fireball extends CardDefinition {	Fireball() {		name='Fireball'; type='spell'; cost=4		text='Deal 6 damage.'		reserved_to="Mage"		get_targets=[ { all_targets } ]		when_played(text) { 			this_spell.deal_spell_damage(6, select_spell_target(all_targets)) 		}	}}class Flamestrike extends CardDefinition {	Flamestrike() {		name='Flamestrike'; type='spell'; cost=7		text='Deal 4 damage to all enemy minions.'		reserved_to="Mage"		when_played(text) { 			this_spell.deal_spell_damage(4, enemy_minions) 		}	}}class Frostbolt extends CardDefinition {	Frostbolt() {		name='Frostbolt'; type='spell'; cost=2		text='Deal 3 damage to a character and Freeze it.'		reserved_to="Mage"		get_targets=[ { all_targets } ]		when_played(text) {			def c = select_spell_target(all_targets)			this_spell.deal_spell_damage(3, c)			this_spell.freeze(c)		}	}}class FrostNova extends CardDefinition {	FrostNova() {		name='Frost Nova'; type='spell'; cost=3		text='Freeze all enemy minions.'		reserved_to="Mage"		when_played(text) {			enemy_minions*.have(FROZEN)		}	}}class IceBarrier extends CardDefinition {	IceBarrier() {		name='Ice Barrier'; type='spell'; cost=3		text='Secret: As soon as your hero is attacked, gain 8 Armor.'		reserved_to="Mage"		is_a_secret=true		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			def the_hero = your_hero				your_hero.when_it_is_attacked("check $text") {				the_secret.activate_if (true) {					the_hero.armor += 8				}			}.run_once()		}	}}class IceLance extends CardDefinition { // tested with ArchmageAntonidas	IceLance() {		name='Ice Lance'; type='spell'; cost=1		text='Freeze a character. If it was already Frozen, deal 4 damage instead.'		reserved_to="Mage"		get_targets=[ { all_characters } ]		when_played(text) {			def c = select_spell_target(all_characters)			if (c.is_frozen()) {				this_spell.deal_spell_damage(4, c)			} else {				this_spell.freeze(c)			}		}	}}class IceBlock extends CardDefinition {	IceBlock() {		name='Ice Block'; type='spell'; cost=3		text='Secret: When your hero takes fatal damage, prevent it and become Immune this turn.'		reserved_to="Mage"		is_a_secret=true		when_played(text) {			def the_secret = you.create_secret(this_spell)			def the_hero = your_hero			your_hero.when_a_hero_takes_damage(text) {				the_secret.activate_if (the_hero.get_health() <= 0) {					the_hero.health += damage_amount // gives back the lost health					println "   - fatal damage is prevented, $this health back to ${the_hero.health}"					the_hero.gain(IMMUNE).until_your_next_turn()				}			}.until { the_secret.is_revealed() }		}	}}class KirinTorMage extends CardDefinition {	KirinTorMage() {		name='Kirin Tor Mage'; type='minion'; cost=3; attack=4; max_health=3		text='Battlecry: The next Secret you play this turn costs (0).'		reserved_to="Mage"		when_played(text) {			/*			 * Link the effect to the hero, not to KTM.			 * If KTM is killed before end of turn, the effect will be removed 			 * and we want the effect to last until end of turn.			 */			boolean already_done = false			your_hero.before_its_controller_plays_a_card(text) {				if (that_card.is_a_secret && !already_done) {					that_card.cost = 0					already_done = true				}			}.until_end_of_turn()		}	}}class Malygos extends CardDefinition {	Malygos() {		name='Malygos'; type='minion'; creature_type='dragon'; cost=9; attack=4; max_health=12		text='Spell Damage +5'		when_coming_in_play(text) {			this_minion.gain("Spell Damage +5")		}	}}class ManaWyrm extends CardDefinition {	ManaWyrm() {		name='Mana Wyrm'; type='minion'; cost=1; attack=1; max_health=3		text='Whenever you cast a spell, gain +1 Attack.'		reserved_to="Mage"		when_coming_in_play(text) {			def mana_wyrm = this_minion			this_minion.when_a_spell_is_played(text) {				if (that_spell.controller == mana_wyrm.controller) {					// note: gain +1 Attack even if the spell is countered					mana_wyrm.gain("+1 Attack")				}			}		}	}}class MirrorEntity extends CardDefinition {	MirrorEntity() {		name='Mirror Entity'; type='spell'; cost=3		text='Secret: When your opponent plays a minion, summon a copy of it.'		reserved_to="Mage"		is_a_secret=true		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			def the_opponent = opponent			the_secret.when_a_minion_is_played("check $text") {				the_secret.activate_if (that_minion.controller == the_opponent) {					Game.summon(the_secret.controller, that_minion.get_copy())				}			}		}	}}class MirrorImageMinion extends CardDefinition {	MirrorImageMinion() {		name='Mirror Image'; type='minion'; cost=0; attack=0; max_health=2		text='Taunt'		reserved_to="Mage"		collectible=false		when_coming_in_play(text) { 			this_minion.gain(TAUNT) 		}	}}class MirrorImage extends CardDefinition {	MirrorImage() {		name='Mirror Image'; type='spell'; cost=1		text='Summon two 0/2 minions with Taunt.'		reserved_to="Mage"		before_play("check targets") {			Game.check(you.minions.size() < 7, "no space left in battlefield")		}		when_played(text) {			Game.summon(you, "Mirror Image Minion")			if (you.minions.size() < 7) {				Game.summon(you, "Mirror Image Minion")			}		}	}}class Polymorph extends CardDefinition {	Polymorph() {		name='Polymorph'; type='spell'; cost=4		text='Transform a minion into a 1/1 Sheep.'		reserved_to="Mage"		get_targets=[ { all_minion_targets } ]		when_played(text) {			this_spell.transform( select_spell_target(all_minion_targets), "Sheep" )		}	}}class Pyroblast extends CardDefinition {	Pyroblast() {		name='Pyroblast'; type='spell'; cost=10		text='Deal 10 damage.'		reserved_to="Mage"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(10, select_spell_target(all_targets))		}	}}class Sheep extends CardDefinition {	Sheep() {		name='Sheep'; type='minion'; creature_type='beast'; cost=0; attack=1; max_health=1		collectible=false	}}class SorcerersApprentice extends CardDefinition {	SorcerersApprentice() {		name="Sorcerer's Apprentice"; type='minion'; cost=2; attack=3; max_health=2		text='Your spells cost (1) less.'		reserved_to="Mage"		when_played(text) {			def sorcerer = this_minion			this_minion.when_a_cost_is_evaluated(text) {				if (that_target.is_a_spell() && that_target.controller == sorcerer.controller) {					cost_increase -= 1				}			}		}	}}class Spellbender extends CardDefinition {	Spellbender() {		name='Spellbender'; type='spell'; cost=3		text='Secret: When an enemy casts a spell on a minion, summon a 1/3 as the new target.'		reserved_to="Mage"		is_a_secret=true		when_played(text) {			def the_secret = you.create_secret(this_spell)			the_secret.when_a_spell_target_is_selected("check $text") {				the_secret.activate_if (that_player != the_secret.controller) {					Card m = Game.new_card("SpellbenderMinion")					Game.summon(the_secret.controller, m)					chosen_target = m				}			}		}	}}class SpellbenderMinion extends CardDefinition {	SpellbenderMinion() {		name='Spellbender'; type='minion'; cost=0; attack=1; max_health=3		reserved_to="Mage"		collectible = false	}}class Vaporize extends CardDefinition {	Vaporize() {		name='Vaporize'; type='spell'; cost=3		text='Secret: When a minion attacks your hero, destroy it.'		reserved_to="Mage"		is_a_secret=true		when_played("create $text") {			def _the_secret = you.create_secret(this_spell)			_the_secret.when_a_character_attacks("check $text") {				_the_secret.activate_if(					attacker.is_a_minion() &&					attacked == _the_secret.controller.hero)				{					_the_secret.destroy(attacker)				}			}		}	}}class WaterElemental extends CardDefinition {	WaterElemental() {		name='Water Elemental'; type='minion'; cost=4; attack=3; max_health=6		text='Freeze any character damaged by this minion.'		reserved_to="Mage"		when_coming_in_play("add $text") {			def _elemental = this_minion			_elemental.when_it_deals_damage("check $text") {				this_minion.freeze(that_target)			}		}	}}