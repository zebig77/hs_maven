package cardsimport game.Cardimport game.CardDefinitionimport game.Gameimport static mechanics.buffs.BuffType.DIVINE_SHIELDimport static mechanics.buffs.BuffType.TAUNT
class AldorPeacekeeper extends CardDefinition {
	AldorPeacekeeper() {
		name='Aldor Peacekeeper'; type='minion'; cost=3; attack=3; max_health=3
		text="Battlecry: Change an enemy minion's Attack to 1."
		reserved_to="Paladin"		get_targets=[ { enemy_minion_targets } ]
		when_played(text) { 			select_target(enemy_minion_targets)?.gain('change attack to 1') 		}
	}
}class ArgentProtector extends CardDefinition {	ArgentProtector() {		name='Argent Protector'; type='minion'; cost=2; attack=2; max_health=2		text='Battlecry: Give a friendly minion Divine Shield'		reserved_to="Paladin"		get_targets=[ { your_minion_targets } ]		when_played(text) { 			select_target(your_minion_targets)?.gain(DIVINE_SHIELD) 		}	}}class Avenge extends CardDefinition {	Avenge() {		name='Avenge'; type='spell'; cost=1		text='Secret: When one of your minions dies, give a random friendly minion +3/+2.'		reserved_to="Paladin"		is_a_secret=true		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			the_secret.when_a_minion_dies("check $text") {				the_secret.activate_if (the_secret.controller == that_minion.controller) {					random_card(the_secret.controller.minions())?.gain('+3/+2')				}			}		}	}}class AvengingWrath extends CardDefinition {	AvengingWrath() {		name='Avenging Wrath'; type='spell'; cost=6		text='Deal 8 damage randomly split among enemy characters'		reserved_to="Paladin"		when_played(text) {			for (i in 1..you.get_spell_damage(8)) {				def t = random_pick(opponent_hero + enemy_minions)				this_spell.deal_damage(1, t)			}		}	}}class BlessedChampion extends CardDefinition {	BlessedChampion() {		name='Blessed Champion'; type='spell'; cost=5		text="Double a minion's Attack."		reserved_to="Paladin"		get_targets=[ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			m.gain('+'+m.get_attack()+' Attack')		}	}}class BlessingOfKings extends CardDefinition {	BlessingOfKings() {		name='Blessing of Kings'; type='spell'; cost=4		text='Give a minion +4/+4. (+4 Attack/+4 Health)'		reserved_to="Paladin"		get_targets=[ { all_minion_targets } ]		when_played(text) { 			select_spell_target(all_minion_targets)?.gain('+4/+4') 		}    }}class BlessingOfMight extends CardDefinition {	BlessingOfMight() {		name='Blessing of Might'; type='spell'; cost=1		text='Give a minion +3 Attack.'		reserved_to="Paladin"		get_targets=[ { all_minion_targets } ]		when_played(text) { 			select_spell_target(all_minion_targets)?.gain('+3 Attack') 		}   }}class BlessingOfWisdom extends CardDefinition {	BlessingOfWisdom() {		name='Blessing of Wisdom'; type='spell'; cost=1		text='Choose a minion. Whenever it attacks, draw a card.'		reserved_to="Paladin"		get_targets=[ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			m.when_it_attacks('draw a card'){				m.controller.draw(1)			}		}	}}class Consecration extends CardDefinition {	Consecration() {		name='Consecration'; type='spell'; cost=4		text='Deal 2 damage to all enemies.'		reserved_to="Paladin"		when_played(text) {			this_spell.deal_spell_damage(2, opponent_hero + enemy_minions)		}    }}class Defender extends CardDefinition {	Defender() {		name='Defender'; type='minion'; cost=1; attack=2; max_health=1		collectible=false		reserved_to="Paladin"   }}class DivineFavor extends CardDefinition {	DivineFavor() { // Junit OK check def		name='Divine Favor'; type='spell'; cost=3		text='Draw cards until you have as many in hand as your opponent'		reserved_to="Paladin"		when_played(text) {			you.draw( opponent.hand.size() - you.hand.size() )		}	}}class Equality extends CardDefinition {	Equality() {		name='Equality'; type='spell'; cost=2		text='Change the Health of ALL minions to 1.'		reserved_to="Paladin"		when_played(text) { 			all_minions*.have("change health to 1") 		}    }}class EyeForAnEye extends CardDefinition {	EyeForAnEye() {		name='Eye for an Eye'; type='spell'; cost=1		text='Secret: When your hero takes damage, deal that much damage to the enemy hero.'		reserved_to="Paladin"		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			the_secret.when_a_hero_takes_damage("check $text") {				the_secret.activate_if(damaged_target == this_spell.controller.hero) {					this_spell.deal_damage(damage_amount, your_hero)				}			}		}	}}class GuardianOfKings extends CardDefinition {	GuardianOfKings() {		name='Guardian of Kings'; type='minion'; cost=7; attack=5; max_health=6		text='Battlecry: Restore 6 Health to your hero.'		reserved_to="Paladin"		when_played(text) {			this_minion.restore_health(6, your_hero)		}	}}class HammerOfWrath extends CardDefinition {	HammerOfWrath() {		name='Hammer of Wrath'; type='spell'; cost=4		text='Deal 3 damage. Draw a card.'		reserved_to="Paladin"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(3, select_spell_target(all_targets))			you.draw(1)		}	}}class HandOfProtection extends CardDefinition {	HandOfProtection() {		name='Hand of Protection'; type='spell'; cost=1		text='Give a minion Divine Shield.'		reserved_to="Paladin"		get_targets=[ { all_minion_targets } ]		when_played(text) {			select_spell_target(all_minion_targets).gain(DIVINE_SHIELD)		}	}}class HolyLight extends CardDefinition {	HolyLight() {		name='Holy Light'; type='spell'; cost=2		text='Restore 6 Health.'		reserved_to="Paladin"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.restore_health(6, select_spell_target(all_targets))		}	}}class HolyWrath extends CardDefinition {	HolyWrath() {		name='Holy Wrath'; type='spell'; cost=5		text='Draw a card and deal damage equal to its cost.'		reserved_to="Paladin"		get_targets=[ { all_targets } ]		before_play("check deck size") {			Game.check( you.deck.cards.size() > 0, 'your deck is empty')		}		when_played(text) {			Card next_to_draw = you.deck.cards[0]			you.draw(1)			this_spell.deal_spell_damage(next_to_draw.get_cost(), select_spell_target(all_targets))		}	}}class Humility extends CardDefinition {	Humility() {		name='Humility'; type='spell'; cost=1		text="Change a minion's attack to 1."		reserved_to="Paladin"		get_targets=[ { all_minion_targets } ]		when_played(text) {			select_spell_target(all_minion_targets).gain("change attack to 1")		}	}}class LayOnHands extends CardDefinition {	LayOnHands() {		name='Lay on Hands'; type='spell'; cost=8		text='Restore 8 Health. Draw 3 cards.'		reserved_to="Paladin"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.restore_health(8, select_spell_target(all_targets))			you.draw(3)		}	}}class LightsJustice extends CardDefinition {	LightsJustice() {		name="Light's Justice"; type='weapon'; cost=1; attack=1; max_health=4		reserved_to="Paladin"    }}
class NobleSacrifice extends CardDefinition {	NobleSacrifice() {		name='Noble Sacrifice'; type='spell'; cost=1		text='Secret: When an enemy attacks, summon a 2/1 Defender as the new target.'		reserved_to="Paladin"		is_a_secret=true		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			the_secret.when_a_character_attacks("check $text") {				the_secret.activate_if (attacker.controller != the_secret.controller) {					def defender = Game.summon(the_secret.controller, "Defender")					changed_attacked = defender				}			}		}	}}
class Redemption extends CardDefinition {	Redemption() {		name='Redemption'; type='spell'; cost=1		text='Secret: When one of your minions dies, return it to life with 1 Health.'		is_a_secret=true		reserved_to="Paladin"		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			the_secret.when_a_minion_dies("check $text") {				the_secret.activate_if (that_minion.controller == the_secret.controller) {					that_minion.health = 1					that_minion.check_enrage_status()					Game.summon(that_minion.controller, that_minion)				}			}		}	}}
class Repentance extends CardDefinition {	Repentance() {		name='Repentance'; type='spell'; cost=1		text='Secret: When your opponent plays a minion, reduce its health to 1'		is_a_secret=true		reserved_to="Paladin"		when_played("create $text") {			def the_secret = you.create_secret(this_spell)			the_secret.when_a_minion_is_played("check $text") {				the_secret.activate_if(that_minion.controller != the_secret.controller) {					that_minion.set_max_health(1)				}			}		}	}}class SilverHandRecruit extends CardDefinition {	SilverHandRecruit() {		name='Silver Hand Recruit'; type='minion'; cost=1; attack=1; max_health=1		collectible=false		reserved_to="Paladin"	}}class SwordOfJustice extends CardDefinition {	SwordOfJustice() {		name='Sword of Justice'; type='weapon'; cost=3; attack=1; max_health=5		text='Whenever you summon a minion, give it +1/+1 and this loses 1 Durability.'		reserved_to="Paladin"		when_played(text) {			def sword = your_hero.weapon			sword.when_a_minion_is_summoned("check $text") {				if (that_minion.controller == sword.controller) {					that_minion.gain('+1/+1')					sword.add_durability(-1)				}			}		}	}}class Ashbringer extends CardDefinition {	Ashbringer() {		name='Ashbringer'; type='weapon'; cost=5; attack=5; max_health=3		collectible=false		reserved_to="Paladin"	}}class TirionFordring extends CardDefinition {	TirionFordring() {		name='Tirion Fordring'; type='minion'; cost=8; attack=6; max_health=6		text='Divine Shield. Taunt. Deathrattle: Equip a 5/3 Ashbringer.'		reserved_to="Paladin"		when_coming_in_play(text) {			this_minion.gain(DIVINE_SHIELD)			this_minion.gain(TAUNT)			this_minion.when_it_is_destroyed("Deathrattle: Equip a 5/3 Ashbringer") {				this_minion.controller.hero.equip_weapon("Ashbringer")			}		}	}}class TruesilverChampion extends CardDefinition {	TruesilverChampion() {		name='Truesilver Champion'; type='weapon'; cost=4; attack=4; max_health=2		text='Whenever your hero attacks, restore 2 Health to it.'		reserved_to="Paladin"		when_played("add '$text'") {			def _truesilver = your_hero.weapon			_truesilver.when_a_character_attacks("check $text") {				def _your_hero = _truesilver.controller.hero				if (attacker == _your_hero) {					_truesilver.restore_health(2, _your_hero)				}			}		}	}}