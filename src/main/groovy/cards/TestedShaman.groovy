package cardsimport static mechanics.buffs.BuffType.CHARGEimport static mechanics.buffs.BuffType.DIVINE_SHIELDimport static mechanics.buffs.BuffType.RETURN_TO_BATTLEFIELD_WHEN_DESTROYEDimport static mechanics.buffs.BuffType.TAUNTimport static mechanics.buffs.BuffType.WINDFURYimport game.Cardimport game.CardDefinitionimport game.Game
class AlAkirTheWindlord extends CardDefinition {
	AlAkirTheWindlord() {
		name="Al'Akir the Windlord"; type='minion'; cost=8; attack=3; max_health=5
		text='Windfury, Charge, Divine Shield, Taunt'
		reserved_to="Shaman"
		when_coming_in_play(text) {
			this_minion.gain( WINDFURY )
			this_minion.gain( CHARGE )
			this_minion.gain( DIVINE_SHIELD )
			this_minion.gain( TAUNT )
		}
	}
}class AncestralHealing extends CardDefinition {	AncestralHealing() {		name='Ancestral Healing'; type='spell'; cost=0		text='Restore a minion to full Health and give it Taunt.'		reserved_to="Shaman"		get_targets=[ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			m.set_health( m.max_health )			m.gain(TAUNT)		}	}}class AncestralSpirit extends CardDefinition {	AncestralSpirit() {		name='Ancestral Spirit'; type='spell'; cost=2		text='Choose a minion. When that minion is destroyed, return it to the battlefield'		reserved_to="Shaman"		get_targets=[ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			m.gain( RETURN_TO_BATTLEFIELD_WHEN_DESTROYED )			//TODO modify text ?		}	}}class Bloodlust extends CardDefinition {	Bloodlust() {		name='Bloodlust'; type='spell'; cost=5		text='Give your minions +3 Attack this turn.'		reserved_to="Shaman"		when_played(text) {			your_minions.each{ it.gain('+3 Attack').until_end_of_turn() }		}	}}class Doomhammer extends CardDefinition {	Doomhammer() {		name='Doomhammer'; type='weapon'; cost=5; attack=2; max_health=8		text='Windfury, Overload: (2)'		reserved_to="Shaman"		when_coming_in_play('Windfury') { this_weapon.gain(WINDFURY) }		when_played('Overload: (2)') { you.add_overload(2) }    }}class DustDevil extends CardDefinition {	DustDevil() {		name='Dust Devil'; type='minion'; cost=1; attack=3; max_health=1		text='Windfury. Overload: (2)'		reserved_to="Shaman"		when_coming_in_play('Windfury') { this_minion.gain(WINDFURY) }		when_played('Overload: (2)') { you.add_overload(2) }    }}

class EarthElemental extends CardDefinition {	EarthElemental() {		name='Earth Elemental'; type='minion'; cost=5; attack=7; max_health=8		text='Taunt. Overload: (3).'		reserved_to="Shaman"		when_coming_in_play('Taunt') { this_minion.gain(TAUNT) }		when_played('Overload: (3)') { you.add_overload(3) }	}}class EarthShock extends CardDefinition {	EarthShock() {		name='Earth Shock'; type='spell'; cost=1		text='Silence a minion, then deal 1 damage to it.'		reserved_to="Shaman"		get_targets=[ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			this_spell.silence(m)			this_spell.deal_spell_damage(1,m)		}	}}class FarSight extends CardDefinition {	FarSight() {		name='Far Sight'; type='spell'; cost=3		text='Draw a card. That card costs (3) less.'		reserved_to="Shaman"		before_play("check deck size") {			Game.check( you.deck.cards.size() > 0, 'your deck is empty')		}		when_played(text) {			you.draw(1)			you.hand.cards.last().gain('costs (3) less')		}	}}class FeralSpirit extends CardDefinition {	FeralSpirit() {		name='Feral Spirit'; type='spell'; cost=3		text='Summon two 2/3 Spirit Wolves with Taunt. Overload: (2)'		reserved_to="Shaman"		when_played(text) {			Game.summon(you, "Spirit Wolf")			Game.summon(you, "Spirit Wolf")			you.add_overload(2)		}   }}class FireElemental extends CardDefinition {	FireElemental() {		name='Fire Elemental'; type='minion'; cost=6; attack=6; max_health=5		text='Battlecry: Deal 3 damage'		reserved_to="Shaman"		get_targets=[ { all_targets } ]		when_played(text) {			this_minion.deal_damage(3, select_target(all_targets))		}	}}class FlametongueTotem extends CardDefinition {	FlametongueTotem() {		name='Flametongue Totem'; type='minion'; creature_type='totem'; cost=2; attack=0; max_health=3		text='Adjacent minions have +2 Attack.'		reserved_to="Shaman"		when_coming_in_play(text) {			def flt = this_minion			flt.when_attack_is_evaluated("check $text") {				if (that_target.is_a_minion() && that_minion.controller == flt.controller) {					if (that_minion.place == flt.place +1 || that_minion.place == flt.place -1) {						attack_increase += 2					}				}			}		}	}}class ForkedLightning extends CardDefinition {	ForkedLightning() {		name='Forked Lightning'; type='spell'; cost=1		text='Deal 2 damage to 2 random enemy minions. Overload: (2)'		reserved_to="Shaman"		before_play("check targets") { 			Game.check( enemy_minions.size() >= 2, 'not enough targets') 		}		when_played(text) {			def choose_from = enemy_minions			2.times {				Collections.shuffle(choose_from)				def chosen = choose_from.remove(0)				this_spell.deal_spell_damage(2, chosen)			}			you.add_overload(2)		}	}}class Frog extends CardDefinition {	Frog() {		name='Frog'; type='minion'; creature_type="beast"; cost=0; attack=0; max_health=1		text='Taunt'		collectible=false		when_coming_in_play(text) {			this_minion.gain(TAUNT)		}	}}class FrostShock extends CardDefinition {	FrostShock() {		name='Frost Shock'; type='spell'; cost=1		text='Deal 1 damage to an enemy character and Freeze it.'		reserved_to="Shaman"		get_targets=[ { enemy_minion_targets + opponent_hero } ]		when_played(text) {			def t = select_spell_target(enemy_minion_targets + opponent_hero)			this_spell.deal_spell_damage(1, t)			this_spell.freeze(t)		}	}}class HealingTotem extends CardDefinition {	HealingTotem() {		name='Healing Totem'; type='minion'; creature_type='totem'; cost=1; attack=0; max_health=2		text='At the end of your turn, restore 1 Health to all friendly minions.'		reserved_to="Shaman"		when_coming_in_play(text) {			def healing_totem = this_minion			healing_totem.when_its_controller_turn_ends(text) {				healing_totem.restore_health(1, healing_totem.controller.minions())			}		}	}}class Hex extends CardDefinition {	Hex() {		name='Hex'; type='spell'; cost=3		text='Transform a minion into a 0/1 Frog with Taunt'		reserved_to="Shaman"		get_targets=[ { all_minion_targets } ]		when_played(text) {			this_spell.transform( select_spell_target(all_minion_targets), "Frog" )		}	}}class LavaBurst extends CardDefinition {	LavaBurst() {		name='Lava Burst'; type='spell'; cost=3		text='Deal 5 damage. Overload: (2)'		reserved_to="Shaman"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(5, select_spell_target(all_targets))			you.add_overload(2)		}	}}class LightningBolt extends CardDefinition {	LightningBolt() {		name='Lightning Bolt'; type='spell'; cost=1		text='Deal 3 damage. Overload: (1)'		reserved_to="Shaman"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(3, select_spell_target(all_targets))			you.add_overload(1)		}	}}class LightningStorm extends CardDefinition {	LightningStorm() {		name='Lightning Storm'; type='spell'; cost=3		text='Deal 2-3 damage to all enemy minions. Overload: (2)'		reserved_to="Shaman"		when_played(text) {			enemy_minions.each {				this_spell.deal_spell_damage(2 + Game.get_random_int(2), it)			}			you.add_overload(2)		}	}}class ManaTideTotem extends CardDefinition {	ManaTideTotem() {		name='Mana Tide Totem'; type='minion'; creature_type='totem'; cost=3; attack=0; max_health=3		text="At the end of your turn, draw a card."		reserved_to="Shaman"		when_coming_in_play(text) {			def mtt = this_minion			this_minion.when_its_controller_turn_ends(text) {				mtt.controller.draw(1)			}		}	}}class Reincarnate extends CardDefinition {	Reincarnate() {		name='Reincarnate'; type='spell'; cost=2		text='Destroy a minion, then return it to life with full Health.'		reserved_to="Shaman"		get_targets=[ { all_minion_targets } ]		when_played(text) {			Card _m = select_spell_target(all_minion_targets)			this_spell.destroy(_m)			Game.summon(_m.controller, _m.name)		}	}}class RockbiterWeapon extends CardDefinition {	RockbiterWeapon() {		name='Rockbiter Weapon'; type='spell'; cost=1		text='Give a friendly character +3 Attack this turn.'		reserved_to="Shaman"		get_targets=[ { your_minion_targets + your_hero } ]		when_played(text) {			def friendly_characters = your_minion_targets + your_hero			select_spell_target(friendly_characters).gain('+3 Attack').until_end_of_turn()		}	}}class SearingTotem extends CardDefinition {	SearingTotem() {		name='Searing Totem'; type='minion'; creature_type='totem'; cost=1; attack=1; max_health=1		collectible=false		reserved_to="Shaman"	}}class SpiritWolf extends CardDefinition {	SpiritWolf() {		name="Spirit Wolf"; type="minion"; cost=2; attack=2; max_health=3		text='Taunt'		collectible=false		reserved_to="Shaman"		when_coming_in_play(text) { this_minion.gain(TAUNT) }	}}class StoneclawTotem extends CardDefinition {	StoneclawTotem() {		name='Stoneclaw Totem'; type='minion'; creature_type='totem'; cost=1; attack=0; max_health=2		text='Taunt'		reserved_to="Shaman"		when_coming_in_play(text) {			this_minion.gain(TAUNT)		}	}}class StormforgedAxe extends CardDefinition {	StormforgedAxe() {		name='Stormforged Axe'; type='weapon'; cost=2; attack=2; max_health=3		text='Overload: (1)'		reserved_to="Shaman"		when_played(text) {			you.add_overload(1)		}	}}class TotemicMight extends CardDefinition {	TotemicMight() {		name='Totemic Might'; type='spell'; cost=0		text='Give your Totems +2 Health.'		reserved_to="Shaman"		when_played(text) {			List<Card> your_totems = your_minions.findAll{it.is_a_totem()}			your_totems*.gain('+2 health')		}	}}class UnboundElemental extends CardDefinition {	UnboundElemental() {		name='Unbound Elemental'; type='minion'; cost=3; attack=2; max_health=4		text='Whenever you play a card with Overload, gain +1/+1.'		reserved_to="Shaman"		when_coming_in_play("add $text") {			def _unbound_elem = this_minion			_unbound_elem.when_its_controller_plays_a_card("check $text") {				def matcher = that_card.text =~ /.*Overload: \(\d+\).*/				if (matcher.matches()) {					_unbound_elem.gain('+1/+1')				}			}		}	}}class Windfury extends CardDefinition {	Windfury() {		name='Windfury'; type='spell'; cost=2		text='Give a minion Windfury.'		reserved_to="Shaman"		get_targets=[ { all_minion_targets } ]		when_played(text) {			select_spell_target(all_minion_targets)?.gain(WINDFURY)		}	}}class Windspeaker extends CardDefinition {	Windspeaker() {		name='Windspeaker'; type='minion'; cost=4; attack=3; max_health=3		text='Battlecry: Give a friendly minion Windfury.'		reserved_to="Shaman"		get_targets=[ { your_minions } ]		when_played(text) {			if (your_minions.size() > 0) {				select_target(your_minions)?.gain(WINDFURY)			}		}	}}class WrathOfAirTotem extends CardDefinition {	WrathOfAirTotem() {		name='Wrath of Air Totem'; type='minion'; creature_type='totem'; cost=1; attack=0; max_health=2		text='Spell Damage +1'		reserved_to="Shaman"		when_coming_in_play(text) {			this_minion.gain("Spell Damage +1")		}	}}