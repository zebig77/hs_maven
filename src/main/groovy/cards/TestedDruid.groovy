package cardsimport game.CardDefinitionimport game.Gameimport static mechanics.buffs.BuffType.TAUNTimport static mechanics.buffs.BuffType.CHARGEimport static mechanics.buffs.BuffType.DIE_AT_THE_END_OF_TURNclass AncientOfLore extends CardDefinition {
	AncientOfLore() {
		name='Ancient of Lore'; type='minion'; cost=7; attack=5; max_health=5
		text='Choose One - Draw 2 cards; or Restore 5 Health.'
		reserved_to="Druid"		druid_choices = [ 'Draw 2 cards','Restore 5 Health' ]		get_targets = [ null, { all_targets } ]
		when_played(text) {
			def script1 = {	you.draw(2) }
			def script2 = {	this_minion.restore_health(5, select_spell_target(all_targets)) }
			you.choose(druid_choices, [script1, script2])
		}
	}
}class AncientOfWar extends CardDefinition {	AncientOfWar() {		name='Ancient of War'; type='minion'; cost=7; attack=5; max_health=5		text='Choose One - Taunt and +5 Health; or +5 Attack'		reserved_to="Druid"		druid_choices = [ 'Taunt and +5 Health', '+5 Attack' ]		get_targets = [ null, null ]		when_played(text) {			def script1 = {	this_minion.gain("+5 health"); this_minion.gain(TAUNT) }			def script2 = {	this_minion.gain("+5 attack") }			you.choose(druid_choices, [script1, script2])		}	}}class Bite extends CardDefinition {	Bite() {		name='Bite'; type='spell'; cost=4		text='Give your hero +4 Attack this turn and 4 Armor.'		reserved_to="Druid"		when_played(text) {			your_hero.gain("+4 Attack").until_end_of_turn()			your_hero.armor += 4		}	}}class Cenarius extends CardDefinition {	Cenarius() {		name='Cenarius'; type='minion'; cost=9; attack=5; max_health=8		text='Choose One - Give your other minions +2/+2; or Summon two 2/2 Treants with Taunt.'		reserved_to="Druid"		druid_choices = [ 'Give your other minions +2/+2', 'Summon two 2/2 Treants with Taunt' ]		get_targets = [ null, null ]		when_played(text) {			def script1 = {	your_minions*.have("+2/+2") }			def script2 = {				2.times {					Game.summon(you, "Treant").gain(TAUNT)				}			}			you.choose(druid_choices, [script1, script2])		}	}}class Claw extends CardDefinition {	Claw() {		name='Claw'; type='spell'; cost=1		text='Give your hero +2 Attack this turn and 2 Armor.'		reserved_to="Druid"		when_played(text) {			your_hero.gain('+2 Attack').until_end_of_turn()			your_hero.armor += 2		}	}}class DruidOfTheClaw extends CardDefinition {	DruidOfTheClaw() {		name='Druid of the Claw'; type='minion'; cost=5; attack=4; max_health=4		text='Choose One - Charge; or +2 Health and Taunt.'		reserved_to="Druid"		druid_choices = [ 'Charge', '+2 Health and Taunt' ]		get_targets = [ null, null ]		when_played(text) {			def script1 = {	this_minion.gain(CHARGE) }			def script2 = {	this_minion.gain('+2 Health'); this_minion.gain(TAUNT) }			you.choose( druid_choices, [script1, script2])		}	}}class ExcessMana extends CardDefinition {	ExcessMana() {		name='Excess Mana'; type='spell'; cost=0		text='Draw a card. (You can only have 10 Mana in your tray.)'		reserved_to="Druid"		collectible=false		when_played(text) {			you.draw(1)		}	}}class ForceOfNature extends CardDefinition {	ForceOfNature() {		name='Force of Nature'; type='spell'; cost=6		text='Summon three 2/2 Treants with Charge that die at the end of the turn.'		reserved_to="Druid"		when_played(text) {			3.times{				def treant = Game.summon( you, "Treant" )				treant.gain(CHARGE)				treant.gain(DIE_AT_THE_END_OF_TURN)			}		}	}}class HealingTouch extends CardDefinition {	HealingTouch() {		name='Healing Touch'; type='spell'; cost=3		text='Restore 8 Health.'		reserved_to="Druid"		get_targets = [ { all_targets } ]		when_played(text) { 			this_spell.restore_health(8, select_spell_target(all_targets)) 		}	}}class Innervate extends CardDefinition {	Innervate() {		name='Innervate'; type='spell'; cost=0		text='Gain 2 Mana Crystals this turn only.'		reserved_to="Druid"		when_played(text) {			you.add_available_mana(2)		}	}}class IronbarkProtector extends CardDefinition {	IronbarkProtector() {		name='Ironbark Protector'; type='minion'; cost=8; attack=8; max_health=8		text='Taunt'		reserved_to="Druid"		when_coming_in_play(text) { 			this_minion.gain(TAUNT) 		}	}}class KeeperOfTheGrove extends CardDefinition {	KeeperOfTheGrove() {		name='Keeper of the Grove'; type='minion'; cost=4; attack=2; max_health=4		text='Choose One - Deal 2 damage; or Silence a minion.'		reserved_to="Druid"		druid_choices = [ 'Deal 2 damage', 'Silence a minion' ]		get_targets = [ { all_characters } , { all_minions } ]		when_played(text) {			def script1 = {	this_minion.deal_damage(2, select_target(all_characters)) }			def script2 = {	this_minion.silence(select_target(all_minions)) }			you.choose(druid_choices, [script1, script2])		}	}}class MarkOfNature extends CardDefinition {	MarkOfNature() {		name='Mark Of Nature'; type='spell'; cost=3		text='Choose One - Give a minion +4 Attack; or +4 Health and Taunt.'		reserved_to="Druid"		druid_choices = [ 'Give a minion +4 Attack', '+4 Health and Taunt' ]		get_targets = [ { all_minion_targets }, { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			def script1 = {	m.gain("+4 attack") }			def script2 = {	m.gain("+4 health"); m.gain(TAUNT) }			you.choose(druid_choices, [script1, script2])		}	}}class MarkOfTheWild extends CardDefinition { // Tested with Captain's Parrot	MarkOfTheWild() {		name='Mark of the Wild'; type='spell'; cost=2		text='Give a minion Taunt and +2/+2. (+2 Attack/+2 Health)'		reserved_to="Druid"		get_targets = [ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			m.gain(TAUNT)			m.gain("+2/+2")		}	}}class Moonfire extends CardDefinition {	Moonfire() {		name='Moonfire'; type='spell'; cost=0		text='Deal 1 damage.'		reserved_to="Druid"		get_targets = [ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(1, select_spell_target(all_targets))		}	}}class Naturalize extends CardDefinition { // Tested with Captain's Parrot	Naturalize() {		name='Naturalize'; type='spell'; cost=1		text='Destroy a minion. Your opponent draws 2 cards.'		reserved_to="Druid"		get_targets = [ { all_minion_targets } ]		when_played(text) {			this_spell.destroy(select_spell_target(all_minion_targets))			opponent.draw(2)		}	}}class Nourish extends CardDefinition {	Nourish() {		name='Nourish'; type='spell'; cost=5		text='Choose One - Gain 2 Mana Crystals; or Draw 3 cards.'		reserved_to="Druid"		druid_choices = [ 'Gain 2 Mana Crystals', 'Draw 3 cards' ]		get_targets = [ null, null ]		when_played(text) {			def script1 = {	you.add_max_mana(2); you.add_available_mana(2) }			def script2 = {	you.draw(3)	}			you.choose(druid_choices, [script1, script2])		}	}}class Panther extends CardDefinition {	Panther() {		name='Panther'; type='minion'; creature_type='beast'; cost=2; attack=3; max_health=2		text=''		collectible=false		reserved_to="Druid"	}}class PoisonSeeds extends CardDefinition {	PoisonSeeds() {		name='Poison Seeds'; type='spell'; cost=4		text='Destroy all minions and summon 2/2 Treants to replace them.'		reserved_to="Druid"		when_played(text) {			def controllers = all_minions*.controller			this_spell.destroy(all_minions)			controllers.each { controller ->				Game.summon(controller, "Treant")			}		}	}}class PowerOfTheWild extends CardDefinition { // Tested with Nourish	PowerOfTheWild() {		name='Power of the Wild'; type='spell'; cost=2		text='Choose One - Give your minions +1/+1; or summon a 3/2 Panther.'		reserved_to="Druid"		druid_choices = [ 'Give your minions +1/+1', 'Summon a 3/2 Panther' ]		get_targets = [ null, null ]		when_played(text) {			def script1 = {	your_minions*.gain("+1/+1") }			def script2 = {	Game.summon(you, "Panther") }			you.choose(druid_choices, [script1, script2])		}	}}class Starfire extends CardDefinition {	Starfire() {		name='Starfire'; type='spell'; cost=6		text='Deal 5 damage. Draw a card.'		reserved_to="Druid"		get_targets = [ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(5, select_target(all_targets))			you.draw(1)		}	}}class SavageRoar extends CardDefinition {	SavageRoar() {		name='Savage Roar'; type='spell'; cost=3		text='Give your characters +2 Attack this turn.'		reserved_to="Druid"		when_played(text) {			def your_characters = your_minions + your_hero			your_characters.each {				it.gain('+2 Attack').until_end_of_turn()			}		}	}}class Savagery extends CardDefinition {	Savagery() {		name='Savagery'; type='spell'; cost=1		text="Deal damage equal to your hero's Attack to a minion."		 reserved_to="Druid"		 get_targets = [ { all_minion_targets } ]		 when_played(text) {			 this_spell.deal_spell_damage(your_hero.get_attack(), select_spell_target(all_minion_targets))		 }	 }}class SoulOfTheForest extends CardDefinition {	SoulOfTheForest() {		name='Soul of the Forest'; type='spell'; cost=4		text='Give your minions "Deathrattle: Summon a 2/2 Treant."'		reserved_to="Druid"		when_played(text) {			def _you = you			your_minions.each {				it.addText("Deathrattle: Summon a 2/2 Treant")				it.when_it_is_destroyed("Deathrattle: Summon a 2/2 Treant") {					Game.summon(_you, "Treant")				}			}		}	}}class Starfall extends CardDefinition {	Starfall() {		name='Starfall'; type='spell'; cost=5		text='Choose One - Deal 5 damage to a minion; or 2 damage to all enemy minions.'		reserved_to="Druid"		druid_choices = [ 'Deal 5 damage to a minion', '2 damage to all enemy minions']		get_targets = [ { all_minion_targets } , null ]		when_played(text) {			def script1 = {	this_spell.deal_spell_damage(5, select_spell_target(all_minion_targets)) }			def script2 = {	this_spell.deal_spell_damage(2, enemy_minions) }			you.choose(druid_choices, [script1, script2])		}	}}class Swipe extends CardDefinition {	Swipe() {		name='Swipe'; type='spell'; cost=4		text='Deal 4 damage to an enemy and 1 damage to all other enemies.'		reserved_to="Druid"		get_targets = [ { opponent_hero + enemy_minion_targets } ]		when_played(text) {			def enemy_targets = opponent_hero + enemy_minion_targets			def m = select_spell_target(enemy_targets)			this_spell.deal_spell_damage(4, m)			this_spell.deal_spell_damage(1, enemy_minions - m)		}	}}class Treant extends CardDefinition {	Treant() {		name='Treant'; type='minion'; cost=1; attack=2; max_health=2		reserved_to="Druid"	}}class WildGrowth extends CardDefinition {	WildGrowth() {		name='Wild Growth'; type='spell'; cost=2		text='Gain an empty Mana Crystal.'		reserved_to="Druid"		when_played(text) {			if (you.max_mana >= 10) {				you.hand.add(Game.new_card("Excess Mana"))			}			else {				you.max_mana += 1			}		}	}}class Wrath extends CardDefinition {	Wrath() {		name='Wrath'; type='spell'; cost=2		text='Choose One - Deal 3 damage to a minion; or 1 damage and draw a card.'		reserved_to="Druid"		druid_choices = [ 'Deal 3 damage to a minion', 'Deal 1 damage to a minion and draw a card' ]		get_targets = [ { all_minion_targets }, { all_minion_targets } ]		when_played(text) {			def script1 = {				this_spell.deal_spell_damage(3, select_spell_target(all_minion_targets))			}			def script2 = {				this_spell.deal_spell_damage(1, select_spell_target(all_minion_targets))				you.draw(1)			}			you.choose(druid_choices, [script1, script2])		}	}}
