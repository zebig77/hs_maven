package cardsimport game.Cardimport game.CardDefinitionimport game.Gameimport game.HeroPowerimport game.MindShatterimport game.MindSpike
class AuchenaiSoulpriest extends CardDefinition {
	AuchenaiSoulpriest() {
		name='Auchenai Soulpriest'; type='minion'; cost=4; attack=3; max_health=5
		text='Your cards and powers that restore Health now deal damage instead.'
		reserved_to="Priest"		when_coming_in_play(text) {
			this_minion.when_its_controller_heals("deal damage instead of heal") {
				healer.deal_damage(heal_amount, healed)
				stop_action = true
			}		}
	}
}class CabalShadowPriest extends CardDefinition {	CabalShadowPriest() {		name='Cabal Shadow Priest'; type='minion'; cost=6; attack=4; max_health=5		text='Battlecry: Take control of an enemy minion that has 2 or less Attack.'		reserved_to="Priest"		get_targets=[ { enemy_minions.findAll{it.get_attack() <= 2} } ]		when_played(text) {			you.take_control( select_target(enemy_minions.findAll{it.get_attack() <= 2}) )		}	}}class CircleOfHealing extends CardDefinition { //tested with Lightwarden_play junit	CircleOfHealing() {		name='Circle of Healing'; type='spell'; cost=0		text='Restore 4 Health to ALL minions.'		reserved_to="Priest"		when_played(text) {			this_spell.restore_health(4, all_minions)		}	}}class DarkCultist extends CardDefinition {	DarkCultist() {		name='Dark Cultist'; type='minion'; cost=3; attack=3; max_health=4		text='Deathrattle: Give a random friendly minion +3 Health.'		reserved_to="Priest"		when_it_is_destroyed(text) {			random_card(this_minion.controller.minions())?.gain('+3 Health')		}	}}class DivineSpirit extends CardDefinition {	// This spell increases the current health 	// and maximum health of a minion by an amount equal to the current health.	DivineSpirit() {		name='Divine Spirit'; type='spell'; cost=2		text="Double a minion's Health."		reserved_to="Priest"		get_targets=[ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			m.gain("+"+m.health+" health")		}	}}class HolyFire extends CardDefinition {	HolyFire() {		name='Holy Fire'; type='spell'; cost=6		text='Deal 5 damage. Restore 5 Health to your hero.'		reserved_to="Priest"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(5, select_spell_target(all_targets))			this_spell.restore_health(5, your_hero)		}	}}class HolyNova extends CardDefinition {	HolyNova() {		name='Holy Nova'; type='spell'; cost=5		text='Deal 2 damage to all enemies. Restore 2 Health to all friendly characters.'		reserved_to="Priest"		when_played(text) {			def all_enemies = enemy_minions + opponent_hero			def all_friendly_characters = your_minions + your_hero			this_spell.deal_spell_damage(2, all_enemies)			this_spell.restore_health(2, all_friendly_characters)		}	}}class HolySmite extends CardDefinition {	HolySmite() {		name='Holy Smite'; type='spell'; cost=1		text='Deal 2 damage.'		reserved_to="Priest"		get_targets=[ { all_targets } ]		when_played(text) {			this_spell.deal_spell_damage(2, select_spell_target(all_targets))		}	}}class InnerFire extends CardDefinition {	InnerFire() {		name='Inner Fire'; type='spell'; cost=1		text="Change a minion's Attack to be equal to its Health."		reserved_to="Priest"		get_targets=[ { all_minion_targets } ]		when_played(text) {			def m = select_spell_target(all_minion_targets)			m.attack = m.get_health() 		}	}}class Lightspawn extends CardDefinition {	Lightspawn() {		name='Lightspawn'; type='minion'; cost=4; attack=0; max_health=5		text="This minion's Attack is always equal to its Health."		reserved_to="Priest"		when_coming_in_play(text) {			def lightspawn = this_minion			this_minion.when_attack_is_evaluated(text) {				if (that_minion == lightspawn) {					attack_change = that_minion.get_health()				}			}		}	}}class Lightwell extends CardDefinition {	Lightwell() {		name='Lightwell'; type='minion'; cost=2; attack=0; max_health=5		text='At the start of your turn, restore 3 Health to a damaged friendly character.'		reserved_to="Priest"		when_coming_in_play(text) {			def lightwell = this_minion			this_minion.when_its_controller_turn_starts(text) {				def friendly_characters = lightwell.controller.minions() + lightwell.controller.hero				def to_heal = random_pick( friendly_characters.findAll{it.health < it.max_health} )				lightwell.restore_health(3, to_heal)			}		}   }}class MassDispel extends CardDefinition {	MassDispel() {		name='Mass Dispel'; type='spell'; cost=4		text='Silence all enemy minions. Draw a card.'		reserved_to="Priest"		when_played(text) {			enemy_minions.each {				this_spell.silence(it)			}			you.draw(1)		}	}}class MindBlast extends CardDefinition {	MindBlast() {		name='Mind Blast'; type='spell'; cost=2		text='Deal 5 damage to the enemy hero.'		reserved_to="Priest"		when_played(text) {			this_spell.deal_spell_damage(5, opponent_hero)		}	}}class MindControl extends CardDefinition {	MindControl() {		name='Mind Control'; type='spell'; cost=10		text='Take control of an enemy minion.'		reserved_to="Priest"		get_targets=[ { enemy_minion_targets } ]		before_play("check space left in battlefield") {			Game.check( your_minions.size() < 7, "no space left in your battlefield" )		}		when_played(text) {			Card m = select_spell_target(enemy_minion_targets)			you.take_control( m )			/* Note: I disagree with http://www.hearthhead.com/card=8/mind-control#comments :			 * 'you CANNOT attack with the minion you take control of with Mind Control in the same turn'			 * Mind control is not a summon. Controller & place excepted, the card is unchanged.			 * If the minion could attack before but has not attacked, it can now.			 */		}	}}class Mindgames extends CardDefinition {	Mindgames() {		name='Mindgames'; type='spell'; cost=4		text="Put a copy of a random minion from your opponent's deck into the battlefield."		reserved_to="Priest"		when_played(text) {			List<Card> choices = opponent.deck.cards.findAll{(it as Card).type == "minion"}			def card_name			if (choices.size() == 0) {				card_name = "Shadow of Nothing"			}			else {				Collections.shuffle(choices)				card_name = choices[0].name			}			Game.summon(you, card_name)		}	}}class MindVision extends CardDefinition {	MindVision() {		name='Mind Vision'; type='spell'; cost=1		text="Put a copy of a random card in your opponent's hand into your hand."		reserved_to="Priest"		before_play("opponent hand size") {			Game.check(opponent.hand.size() > 0, "no card in opponent's hand")		}		when_played(text) {			def i = Game.get_random_int(opponent.hand.size())			def card_name = opponent.hand.cards[i].name			you.hand.add(Game.new_card(card_name))		}	}}class NorthshireCleric extends CardDefinition {	NorthshireCleric() {		name='Northshire Cleric'; type='minion'; cost=1; attack=1; max_health=3		text='Whenever a minion is healed, draw a card.'		reserved_to="Priest"		when_coming_in_play(text) {			def cleric = this_minion			this_minion.when_a_character_is_healed("checking $text") {				if (that_character.is_a_minion()) {					cleric.controller.draw(1)				}			}		}	}}class PowerWordShield extends CardDefinition {	PowerWordShield() {		name='Power Word: Shield'; type='spell'; cost=1		text='Give a minion +2 Health. Draw a card.'		reserved_to="Priest"		get_targets=[ { all_minion_targets } ]		when_played(text) {			select_spell_target(all_minion_targets).gain('+2 Health')			you.draw(1)		}	}}class ProphetVelen extends CardDefinition {	ProphetVelen() {		name='Prophet Velen'; type='minion'; cost=7; attack=7; max_health=7		text='Double the damage and healing of your spells and hero power.'		reserved_to="Priest"		when_coming_in_play(text) {			this_minion.when_spell_damage_is_evaluated("double spell damage") {				spell_damage_increase += (spell_damage_amount + spell_damage_increase)			}			this_minion.when_power_damage_is_evaluated("double hero power damage") {				power_damage_increase += (power_damage_amount + power_damage_increase)			}			this_minion.when_spell_healing_is_evaluated("double spell healing") {				spell_healing_increase += (spell_healing_amount + spell_healing_increase)			}			this_minion.when_power_healing_is_evaluated("double hero power healing") {				power_healing_increase += (power_healing_amount + power_healing_increase)			}		}	}}class ShadowMadness extends CardDefinition {	ShadowMadness() {		name='Shadow Madness'; type='spell'; cost=4		text='Gain control of an enemy minion with 3 or less Attack until end of turn.'		reserved_to="Priest"		get_targets=[ { enemy_minion_targets.findAll{it.get_attack() <= 3} } ]		before_play("check space left in your battlefield") {			Game.check( your_minions.size() < 7, 'no space left in your battlefield' )		}		when_played(text) {			def m = select_spell_target(enemy_minion_targets)			def previous_controller = m.controller			you.take_control(m)			m.when_its_controller_turn_ends("restore previous control") {				previous_controller.take_control(m)			}		}	}}class ShadowOfNothing extends CardDefinition {	ShadowOfNothing() {		name='Shadow of Nothing'; type='minion'; cost=0; attack=0; max_health=1		text='Mindgames whiffed! Your opponent had no minions!'		reserved_to="Priest"	}}
class Shadowform extends CardDefinition {	Shadowform() {		name='Shadowform'; type='spell'; cost=3		text="Your Hero Power becomes 'Deal 2 damage'. If already in Shadowform: 3 damage."		reserved_to="Priest"		when_played(text) {			if (your_hero.power.name == "Lesser Heal") {				your_hero.power = new HeroPower(MindSpike.instance)			}			else if (your_hero.power.name == "Mind Spike") {				your_hero.power = new HeroPower(MindShatter.instance)			}			else { // possible in Arena ?				return // do nothing or new MindShatter ?			}			println "   - ${your_hero}'s power becomes ${your_hero.power.name}"		}	}}class ShadowWordDeath extends CardDefinition {	ShadowWordDeath() {		name='Shadow Word: Death'; type='spell'; cost=3		text='Destroy a minion with an Attack of 5 or more.'		reserved_to="Priest"		get_targets=[ { all_minion_targets.findAll{it.get_attack() >= 5} } ]		when_played(text) {			this_spell.destroy(select_spell_target(all_minion_targets.findAll{it.get_attack() >= 5}))		}	}}class ShadowWordPain extends CardDefinition {	ShadowWordPain() {		name='Shadow Word: Pain'; type='spell'; cost=2		text='Destroy a minion with 3 or less Attack.'		reserved_to="Priest"		get_targets=[ { all_minion_targets.findAll{it.get_attack() <= 3} } ]		when_played(text) {			this_spell.destroy(select_spell_target(all_minion_targets.findAll{it.get_attack() <= 3}))		}	}}class Silence extends CardDefinition {	Silence() {		name='Silence'; type='spell'; cost=0		text='Silence a minion.'		reserved_to="Priest"		get_targets=[ { all_minion_targets } ]		when_played(text) { 			this_spell.silence( select_spell_target(all_minion_targets) ) 		}    }}class TempleEnforcer extends CardDefinition {	TempleEnforcer() {		name='Temple Enforcer'; type='minion'; cost=6; attack=6; max_health=6		text='Battlecry: Give a friendly minion +3 Health.'		reserved_to="Priest"		get_targets=[ { your_minions } ]		when_played {			select_target(your_minions)?.gain('+3 Health')		}	}}class Thoughtsteal extends CardDefinition {	Thoughtsteal() {		name='Thoughtsteal'; type='spell'; cost=3		text="Copy 2 cards from your opponent's deck and put them into your hand."		reserved_to="Priest"		before_play("checking opponent's deck size") {			Game.check(opponent.deck.size() >= 2, "not enough cards in opponent's deck")		}		when_played {			def deck_copy = new ArrayList<Card>(opponent.deck.cards.storage) 			Collections.shuffle(deck_copy)			you.hand.add(deck_copy[0].get_copy())			you.hand.add(deck_copy[1].get_copy())		}	}}